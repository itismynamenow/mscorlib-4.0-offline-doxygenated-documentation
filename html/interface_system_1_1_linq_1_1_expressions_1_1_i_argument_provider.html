<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mscorlib(4.0.0.0) API with additions: System.Linq.Expressions.IArgumentProvider Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mscorlib(4.0.0.0) API with additions
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('interface_system_1_1_linq_1_1_expressions_1_1_i_argument_provider.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="interface_system_1_1_linq_1_1_expressions_1_1_i_argument_provider-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">System.Linq.Expressions.IArgumentProvider Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides an internal interface for accessing the arguments of multiple tree nodes (<a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_dynamic_expression.html" title="Represents a dynamic operation.">DynamicExpression</a>, <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_element_init.html" title="Represents an initializer for a single element of an T:System.Collections.IEnumerable collection.">ElementInit</a>, <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_method_call_expression.html" title="Represents a call to either static or an instance method.">MethodCallExpression</a>, <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_invocation_expression.html" title="Represents an expression that applies a delegate or lambda expression to a list of argument expressio...">InvocationExpression</a>, <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_new_expression.html" title="Represents a constructor call.">NewExpression</a>, and InexExpression). You should not use this API. It is only public due to DLL refactoring and exists only for internal performance optimizations.This enables two optimizations which reduce the size of expression trees. The first enables the tree nodes to hold onto an IList&lt;T&gt; instead of a ReadOnlyCollection. IList&lt;T&gt; saves the cost of allocating the ReadOnlyCollection for each node. The second enables creating specialized subclasses that hold onto a specific number of arguments (for example, Block2, Block3, Block4). Therefore, these nodes avoid allocating both a ReadOnlyCollection and an array for storing their elements, saving 32 bytes per node.The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections. The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array.For the array case, the collection is typed to IList&lt;T&gt; instead of ReadOnlyCollection&lt;T&gt;. When the node is initially constructed it is an array. When the compiler accesses the members it uses this interface. Accessing array elements promotes the array to a ReadOnlyCollection.For the object case we store the first argument in a field typed to object. When the node is initially constructed, the field holds the <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_expression.html" title="Represents a strongly typed lambda expression as a data structure in the form of an expression tree....">Expression</a>. The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression.ReturnObject to return the object that handles the <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_expression.html" title="Represents a strongly typed lambda expression as a data structure in the form of an expression tree....">Expression</a> or ReadOnlyCollection case. When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection.It is important that the <a class="el" href="namespace_system_1_1_linq_1_1_expressions.html">Expressions</a> consistently return the same ReadOnlyCollection. Otherwise, the re-writer tree walker will break. It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_expression.html" title="Represents a strongly typed lambda expression as a data structure in the form of an expression tree....">Expression</a> node. Currently users can rely on object identity to tell if the node has changed. Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API.  
 <a href="interface_system_1_1_linq_1_1_expressions_1_1_i_argument_provider.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for System.Linq.Expressions.IArgumentProvider:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="interface_system_1_1_linq_1_1_expressions_1_1_i_argument_provider__inherit__graph.svg" width="631" height="411"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc5305d17ae0d4e376737834381a85dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_system_1_1_linq_1_1_expressions_1_1_i_argument_provider.html#adc5305d17ae0d4e376737834381a85dd">GetArgument</a> (int index)</td></tr>
<tr class="memdesc:adc5305d17ae0d4e376737834381a85dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the argument at index, throwing if index is out of bounds. You should not use this type. It is only public due to assembly refactoring, and it is used internally for performance optimizations.  <a href="#adc5305d17ae0d4e376737834381a85dd">More...</a><br /></td></tr>
<tr class="separator:adc5305d17ae0d4e376737834381a85dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ae24fbabfd0f502ad992e660684d1b0aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_system_1_1_linq_1_1_expressions_1_1_i_argument_provider.html#ae24fbabfd0f502ad992e660684d1b0aa">ArgumentCount</a><code> [get]</code></td></tr>
<tr class="memdesc:ae24fbabfd0f502ad992e660684d1b0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of arguments to the expression tree node. You should not use this type. It is only public due to assembly refactoring, and it is used internally for performance optimizations.  <a href="#ae24fbabfd0f502ad992e660684d1b0aa">More...</a><br /></td></tr>
<tr class="separator:ae24fbabfd0f502ad992e660684d1b0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides an internal interface for accessing the arguments of multiple tree nodes (<a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_dynamic_expression.html" title="Represents a dynamic operation.">DynamicExpression</a>, <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_element_init.html" title="Represents an initializer for a single element of an T:System.Collections.IEnumerable collection.">ElementInit</a>, <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_method_call_expression.html" title="Represents a call to either static or an instance method.">MethodCallExpression</a>, <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_invocation_expression.html" title="Represents an expression that applies a delegate or lambda expression to a list of argument expressio...">InvocationExpression</a>, <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_new_expression.html" title="Represents a constructor call.">NewExpression</a>, and InexExpression). You should not use this API. It is only public due to DLL refactoring and exists only for internal performance optimizations.This enables two optimizations which reduce the size of expression trees. The first enables the tree nodes to hold onto an IList&lt;T&gt; instead of a ReadOnlyCollection. IList&lt;T&gt; saves the cost of allocating the ReadOnlyCollection for each node. The second enables creating specialized subclasses that hold onto a specific number of arguments (for example, Block2, Block3, Block4). Therefore, these nodes avoid allocating both a ReadOnlyCollection and an array for storing their elements, saving 32 bytes per node.The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections. The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array.For the array case, the collection is typed to IList&lt;T&gt; instead of ReadOnlyCollection&lt;T&gt;. When the node is initially constructed it is an array. When the compiler accesses the members it uses this interface. Accessing array elements promotes the array to a ReadOnlyCollection.For the object case we store the first argument in a field typed to object. When the node is initially constructed, the field holds the <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_expression.html" title="Represents a strongly typed lambda expression as a data structure in the form of an expression tree....">Expression</a>. The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression.ReturnObject to return the object that handles the <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_expression.html" title="Represents a strongly typed lambda expression as a data structure in the form of an expression tree....">Expression</a> or ReadOnlyCollection case. When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection.It is important that the <a class="el" href="namespace_system_1_1_linq_1_1_expressions.html">Expressions</a> consistently return the same ReadOnlyCollection. Otherwise, the re-writer tree walker will break. It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same <a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_expression.html" title="Represents a strongly typed lambda expression as a data structure in the form of an expression tree....">Expression</a> node. Currently users can rely on object identity to tell if the node has changed. Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API. </p>

<p class="definition">Definition at line <a class="el" href="_i_argument_provider_8cs_source.html#l00005">5</a> of file <a class="el" href="_i_argument_provider_8cs_source.html">IArgumentProvider.cs</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="adc5305d17ae0d4e376737834381a85dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5305d17ae0d4e376737834381a85dd">&#9670;&nbsp;</a></span>GetArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_linq_1_1_expressions_1_1_expression.html">Expression</a> System.Linq.Expressions.IArgumentProvider.GetArgument </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the argument at index, throwing if index is out of bounds. You should not use this type. It is only public due to assembly refactoring, and it is used internally for performance optimizations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The argument at index, throwing if index is out of bounds as T:System.Linq.Expressions.Expression.</dd></dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="ae24fbabfd0f502ad992e660684d1b0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24fbabfd0f502ad992e660684d1b0aa">&#9670;&nbsp;</a></span>ArgumentCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int System.Linq.Expressions.IArgumentProvider.ArgumentCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of arguments to the expression tree node. You should not use this type. It is only public due to assembly refactoring, and it is used internally for performance optimizations. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of arguments to the expression tree node as <a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863ac06129f6e6e15c09328365e553f1dc31" title="An integral type representing signed 32-bit integers with values between -2147483648 and 2147483647.">T:System.Int32</a>.</dd></dl>

<p class="definition">Definition at line <a class="el" href="_i_argument_provider_8cs_source.html#l00011">11</a> of file <a class="el" href="_i_argument_provider_8cs_source.html">IArgumentProvider.cs</a>.</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>D:/All cs/System.Linq.Expressions/<a class="el" href="_i_argument_provider_8cs_source.html">IArgumentProvider.cs</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_system.html">System</a></li><li class="navelem"><a class="el" href="namespace_system_1_1_linq.html">Linq</a></li><li class="navelem"><a class="el" href="namespace_system_1_1_linq_1_1_expressions.html">Expressions</a></li><li class="navelem"><a class="el" href="interface_system_1_1_linq_1_1_expressions_1_1_i_argument_provider.html">IArgumentProvider</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
